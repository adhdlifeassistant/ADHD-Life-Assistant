import { BaseAuthProvider } from './BaseAuthProvider';
import { User, AuthError } from '@/types/auth';

export class GoogleAuthProvider extends BaseAuthProvider {
  private clientId: string;

  constructor() {
    super();
    this.clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID || '';
    
    if (typeof window !== 'undefined') {
      this.initializeGoogleAuth();
    }
  }

  private async initializeGoogleAuth() {
    try {
      console.log('üîç DEBUG: Initializing Google Auth with Client ID:', this.clientId);
      console.log('üîç DEBUG: Current window.location:', {
        origin: window.location.origin,
        hostname: window.location.hostname,
        port: window.location.port,
        protocol: window.location.protocol,
        href: window.location.href
      });
      
      // Intercepter les requ√™tes pour capturer l'URL de redirection
      this.interceptNetworkRequests();
      
      // Charger le SDK Google Identity Services
      const script = document.createElement('script');
      script.src = 'https://accounts.google.com/gsi/client';
      script.async = true;
      document.head.appendChild(script);

      await new Promise((resolve) => {
        script.onload = resolve;
      });

      // Initialiser Google Identity Services
      if (window.google) {
        const config = {
          client_id: this.clientId,
          callback: this.handleCredentialResponse.bind(this)
        };
        console.log('üîç DEBUG: Google Identity Services config:', config);
        window.google.accounts.id.initialize(config);
      }
    } catch (error) {
      console.error('Erreur lors de l\'initialisation de Google Auth:', error);
    }
  }

  private interceptNetworkRequests() {
    // Intercepter window.open pour capturer les URLs d'OAuth
    const originalWindowOpen = window.open;
    window.open = function(url?: string | URL, target?: string, features?: string) {
      if (url && typeof url === 'string' && url.includes('accounts.google.com/oauth')) {
        console.log('üö® REDIRECT_URI CAPTURE: Google OAuth URL:', url);
        
        // Extraire le redirect_uri de l'URL
        try {
          const urlObj = new URL(url);
          const redirectUri = urlObj.searchParams.get('redirect_uri');
          if (redirectUri) {
            console.log('üéØ REDIRECT_URI EXACT:', redirectUri);
            alert(`REDIRECT_URI CAPTUR√â: ${redirectUri}`);
          }
        } catch (e) {
          console.error('Erreur parsing OAuth URL:', e);
        }
      }
      return originalWindowOpen.call(this, url, target, features);
    };

    // Intercepter les requ√™tes fetch vers Google
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
      const [resource, options] = args;
      const url = typeof resource === 'string' ? resource : resource.url;
      
      if (url.includes('accounts.google.com') || url.includes('oauth2.googleapis.com')) {
        console.log('üîç DEBUG: Google API request:', url, options);
      }
      
      return originalFetch.apply(this, args);
    };

    // Intercepter les changements d'iframe qui pourraient contenir l'OAuth
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName === 'IFRAME') {
              const iframe = node as HTMLIFrameElement;
              if (iframe.src && iframe.src.includes('accounts.google.com')) {
                console.log('üîç DEBUG: Google OAuth iframe detected:', iframe.src);
                
                try {
                  const urlObj = new URL(iframe.src);
                  const redirectUri = urlObj.searchParams.get('redirect_uri');
                  if (redirectUri) {
                    console.log('üéØ IFRAME REDIRECT_URI:', redirectUri);
                    alert(`IFRAME REDIRECT_URI: ${redirectUri}`);
                  }
                } catch (e) {
                  console.error('Erreur parsing iframe URL:', e);
                }
              }
            }
          });
        }
      });
    });
    
    observer.observe(document.body, { childList: true, subtree: true });
  }

  private async handleCredentialResponse(response: any) {
    try {
      const credential = response.credential;
      const decoded = JSON.parse(atob(credential.split('.')[1]));
      
      const user: User = {
        id: decoded.sub,
        email: decoded.email,
        name: decoded.name,
        picture: decoded.picture,
        provider: 'google'
      };

      this._currentUser = user;
      this._isAuthenticated = true;
      this._accessToken = credential;

      localStorage.setItem('auth_user', JSON.stringify(user));
      localStorage.setItem('auth_token', credential);
      localStorage.setItem('auth_provider', 'google');

    } catch (error) {
      throw this.handleError(error);
    }
  }

  async signIn(): Promise<User> {
    return new Promise((resolve, reject) => {
      try {
        console.log('üîç DEBUG: Starting Google Sign-In process');
        
        if (!window.google) {
          throw new Error('Google SDK non charg√©');
        }

        window.google.accounts.id.prompt((notification: any) => {
          console.log('üîç DEBUG: Google prompt notification:', notification);
          if (notification.isNotDisplayed() || notification.isSkippedMoment()) {
            console.log('üîç DEBUG: Prompt not displayed, falling back to popup');
            // Fallback vers popup si la promesse native ne fonctionne pas
            this.signInWithPopup().then(resolve).catch(reject);
          }
        });

        // Timeout pour √©viter d'attendre ind√©finiment
        setTimeout(() => {
          if (!this._isAuthenticated) {
            console.log('üîç DEBUG: Timeout reached, using popup fallback');
            this.signInWithPopup().then(resolve).catch(reject);
          }
        }, 3000);

        // √âcouter les changements d'√©tat d'authentification
        const checkAuth = () => {
          if (this._isAuthenticated && this._currentUser) {
            resolve(this._currentUser);
          }
        };

        const interval = setInterval(() => {
          checkAuth();
          if (this._isAuthenticated) {
            clearInterval(interval);
          }
        }, 100);

        // Nettoyer apr√®s 10 secondes
        setTimeout(() => {
          clearInterval(interval);
        }, 10000);

      } catch (error) {
        reject(this.handleError(error));
      }
    });
  }

  private async signInWithPopup(): Promise<User> {
    return new Promise((resolve, reject) => {
      try {
        console.log('üîç DEBUG: Starting popup sign-in with Client ID:', this.clientId);
        
        if (!window.google) {
          throw new Error('Google SDK non charg√©');
        }

        // Capturer l'URL actuelle pour le debugging
        const currentUrl = window.location.origin;
        console.log('üîç DEBUG: Current origin:', currentUrl);
        console.log('üîç DEBUG: Current full URL:', window.location.href);
        
        const tokenClientConfig = {
          client_id: this.clientId,
          scope: 'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile',
          callback: async (tokenResponse: any) => {
            console.log('üîç DEBUG: Token response received:', tokenResponse);
            try {
              const userInfo = await this.fetchUserInfo(tokenResponse.access_token);
              const user: User = {
                id: userInfo.id,
                email: userInfo.email,
                name: userInfo.name,
                picture: userInfo.picture,
                provider: 'google'
              };

              this._currentUser = user;
              this._isAuthenticated = true;
              this._accessToken = tokenResponse.access_token;
              this._refreshToken = tokenResponse.refresh_token;

              localStorage.setItem('auth_user', JSON.stringify(user));
              localStorage.setItem('auth_token', tokenResponse.access_token);
              localStorage.setItem('auth_refresh_token', tokenResponse.refresh_token || '');
              localStorage.setItem('auth_provider', 'google');

              resolve(user);
            } catch (error) {
              reject(this.handleError(error));
            }
          },
          error_callback: (error: any) => {
            console.log('üîç DEBUG: OAuth error callback:', error);
            reject(this.handleError(error));
          }
        };
        
        console.log('üîç DEBUG: Creating token client with config:', tokenClientConfig);
        const client = window.google.accounts.oauth2.initTokenClient(tokenClientConfig);

        console.log('üîç DEBUG: Requesting access token...');
        client.requestAccessToken();
      } catch (error) {
        reject(this.handleError(error));
      }
    });
  }

  private async fetchUserInfo(accessToken: string): Promise<any> {
    const response = await fetch(`https://www.googleapis.com/oauth2/v2/userinfo?access_token=${accessToken}`);
    if (!response.ok) {
      throw new Error('Erreur lors de la r√©cup√©ration des informations utilisateur');
    }
    return response.json();
  }

  async signOut(): Promise<void> {
    try {
      if (window.google) {
        window.google.accounts.id.disableAutoSelect();
      }

      this._currentUser = null;
      this._isAuthenticated = false;
      this._accessToken = null;
      this._refreshToken = null;

      localStorage.removeItem('auth_user');
      localStorage.removeItem('auth_token');
      localStorage.removeItem('auth_refresh_token');
      localStorage.removeItem('auth_provider');

    } catch (error) {
      throw this.handleError(error);
    }
  }

  async refreshAccessToken(): Promise<string> {
    try {
      if (!this._refreshToken) {
        throw new Error('Pas de refresh token disponible');
      }

      const response = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
          client_id: this.clientId,
          refresh_token: this._refreshToken,
          grant_type: 'refresh_token',
        }),
      });

      if (!response.ok) {
        throw new Error('Erreur lors du renouvellement du token');
      }

      const data = await response.json();
      this._accessToken = data.access_token;
      
      localStorage.setItem('auth_token', data.access_token);

      return data.access_token;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // M√©thode pour restaurer l'√©tat depuis le localStorage
  restoreSession(): boolean {
    try {
      const user = localStorage.getItem('auth_user');
      const token = localStorage.getItem('auth_token');
      const refreshToken = localStorage.getItem('auth_refresh_token');
      const provider = localStorage.getItem('auth_provider');

      if (user && token && provider === 'google') {
        this._currentUser = JSON.parse(user);
        this._accessToken = token;
        this._refreshToken = refreshToken;
        this._isAuthenticated = true;
        return true;
      }

      return false;
    } catch (error) {
      console.error('Erreur lors de la restauration de session:', error);
      return false;
    }
  }
}

// D√©clarations TypeScript pour les APIs Google
declare global {
  interface Window {
    google: {
      accounts: {
        id: {
          initialize: (config: any) => void;
          prompt: (callback?: (notification: any) => void) => void;
          disableAutoSelect: () => void;
        };
        oauth2: {
          initTokenClient: (config: any) => any;
        };
      };
    };
  }
}